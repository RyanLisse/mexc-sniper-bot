/**
 * Vulnerability Assessment Security Tests
 * 
 * Comprehensive security tests for vulnerability assessment including:
 * - OWASP Top 10 vulnerability testing
 * - Common Weakness Enumeration (CWE) validation
 * - Security misconfiguration detection
 * - Dependency vulnerability scanning
 * - Code injection vulnerability testing
 * - Authentication bypass attempts
 * - Session management vulnerabilities
 * - Business logic flaws
 */

import { describe, it, expect, beforeEach, vi } from 'vitest'
import { SecurityTestDataGenerator, SecurityTestHelpers, SecurityTestMatchers } from '../utils/security-test-utils'
import { requireAuth } from '../../src/lib/supabase-auth'
import { checkRateLimit } from '../../src/lib/rate-limiter'

import { 
  setupTimeoutElimination, 
  withTimeout, 
  TIMEOUT_CONFIG,
  flushPromises 
} from '../../utils/timeout-elimination-helpers';

// Mock external dependencies
vi.mock('../../src/lib/supabase-auth')
vi.mock('../../src/lib/rate-limiter')

const mockRequireAuth = vi.mocked(requireAuth)
const mockCheckRateLimit = vi.mocked(checkRateLimit)

describe('Vulnerability Assessment Security Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('OWASP Top 10 Vulnerability Testing', () => {
    it('should prevent broken access control (A01:2021)', async () => {
      const testUsers = SecurityTestDataGenerator.generateTestUsers()
      
      mockRequireAuth.mockResolvedValueOnce(testUsers.validUser)

      const user = await requireAuth()
      
      // Test access control bypass attempts
      const accessControlTests = [
        { resource: '/api/admin/users', userRole: 'user', shouldHaveAccess: false },
        { resource: '/api/user/profile/other-user-id', userRole: 'user', shouldHaveAccess: false },
        { resource: '/api/trading/orders/other-user-orders', userRole: 'user', shouldHaveAccess: false },
        { resource: '/api/system/config', userRole: 'user', shouldHaveAccess: false }
      ]

      for (const test of accessControlTests) {
        const hasAccess = user.role === 'admin' || user.role === 'superadmin'
        if (test.resource.includes('admin') || test.resource.includes('system')) {
          expect(hasAccess).toBe(false) // Regular user should not have admin access
        }
      }
    })

    it('should prevent cryptographic failures (A02:2021)', () => {
      const cryptographicTests = [
        { data: 'sensitive_password', encrypted: false, isSecure: false },
        { data: 'api_key_mx0abc123', encrypted: false, isSecure: false },
        { data: 'encrypted_sensitive_password', encrypted: true, isSecure: true },
        { data: 'credit_card_number', encrypted: false, isSecure: false }
      ]

      for (const test of cryptographicTests) {
        const isSensitiveData = ['password', 'api_key', 'credit_card'].some(keyword => 
          test.data.toLowerCase().includes(keyword)
        )
        
        if (isSensitiveData) {
          expect(test.encrypted).toBe(test.isSecure)
        }
      }
    })

    it('should prevent injection attacks (A03:2021)', () => {
      const injectionPayloads = SecurityTestDataGenerator.generateSQLInjectionPayloads()
      
      for (const payload of injectionPayloads) {
        // SQL Injection detection
        const hasSQLInjection = /[\'\";]|--|\bUNION\b|\bSELECT\b|\bDROP\b|\bINSERT\b|\bUPDATE\b|\bDELETE\b/i.test(payload)
        expect(hasSQLInjection).toBe(true) // Should detect SQL injection patterns

        // NoSQL Injection detection
        const hasNoSQLInjection = /\$where|\$regex|\$ne|\$gt|\$lt/i.test(payload)
        if (hasNoSQLInjection) {
          expect(hasNoSQLInjection).toBe(true) // Should detect NoSQL injection patterns
        }

        // Command Injection detection
        const hasCommandInjection = /[;&|`$]|exec|system|eval|sh|bash|cmd/i.test(payload)
        if (hasCommandInjection) {
          expect(hasCommandInjection).toBe(true) // Should detect command injection patterns
        }
      }
    })

    it('should prevent insecure design vulnerabilities (A04:2021)', () => {
      const designTests = [
        { feature: 'password_reset', hasRateLimit: true, hasSecureToken: true, isSecure: true },
        { feature: 'trading_api', hasRateLimit: true, hasAuthentication: true, isSecure: true },
        { feature: 'public_api', hasRateLimit: false, hasAuthentication: false, isSecure: false },
        { feature: 'admin_panel', hasRateLimit: true, hasMultiAuth: true, isSecure: true }
      ]

      for (const test of designTests) {
        if (test.feature === 'public_api') {
          expect(test.hasRateLimit).toBe(false) // Should catch insecure design
        } else {
          expect(test.hasRateLimit).toBe(true) // Secure designs should have rate limiting
        }
      }
    })

    it('should prevent security misconfiguration (A05:2021)', () => {
      const configurationTests = [
        { setting: 'debug_mode', environment: 'production', value: 'true', isSecure: false },
        { setting: 'default_password', value: 'admin123', isSecure: false },
        { setting: 'error_details', environment: 'production', value: 'verbose', isSecure: false },
        { setting: 'cors_origin', value: '*', isSecure: false },
        { setting: 'ssl_verify', value: 'false', isSecure: false }
      ]

      for (const test of configurationTests) {
        let isSecure = true

        if (test.setting === 'debug_mode' && test.environment === 'production' && test.value === 'true') {
          isSecure = false
        }
        if (test.setting === 'default_password' && test.value === 'admin123') {
          isSecure = false
        }
        if (test.setting === 'cors_origin' && test.value === '*') {
          isSecure = false
        }
        if (test.setting === 'ssl_verify' && test.value === 'false') {
          isSecure = false
        }

        expect(isSecure).toBe(test.isSecure)
      }
    })

    it('should prevent vulnerable and outdated components (A06:2021)', () => {
      const componentTests = [
        { component: 'lodash', version: '4.17.20', hasKnownVulnerability: true, isSecure: false },
        { component: 'express', version: '4.16.0', hasKnownVulnerability: true, isSecure: false },
        { component: 'react', version: '18.2.0', hasKnownVulnerability: false, isSecure: true },
        { component: 'axios', version: '0.21.0', hasKnownVulnerability: true, isSecure: false }
      ]

      for (const test of componentTests) {
        const isVulnerable = test.hasKnownVulnerability
        expect(isVulnerable).toBe(!test.isSecure)
      }
    })

    it('should prevent identification and authentication failures (A07:2021)', async () => {
      const authenticationTests = [
        { password: 'password123', isWeak: true, allowsLogin: false },
        { password: 'admin', isWeak: true, allowsLogin: false },
        { password: 'StrongP@ssw0rd123!', isWeak: false, allowsLogin: true },
        { sessionId: 'predictable123', isPredictable: true, isSecure: false },
        { sessionId: SecurityTestHelpers.generateSecureRandom(32), isPredictable: false, isSecure: true }
      ]

      for (const test of authenticationTests) {
        if (test.password) {
          const isStrongPassword = test.password.length >= 8 && 
                                 /[A-Z]/.test(test.password) && 
                                 /[a-z]/.test(test.password) && 
                                 /[0-9]/.test(test.password) && 
                                 /[!@#$%^&*]/.test(test.password)
          
          expect(isStrongPassword).toBe(!test.isWeak)
        }

        if (test.sessionId) {
          const isSecureSession = test.sessionId.length >= 32 && !test.isPredictable
          expect(isSecureSession).toBe(test.isSecure)
        }
      }
    })

    it('should prevent software and data integrity failures (A08:2021)', () => {
      const integrityTests = [
        { file: 'package.json', hasChecksum: true, isVerified: true },
        { file: 'critical-config.json', hasChecksum: false, isVerified: false },
        { update: 'auto-update', isVerified: false, isSecure: false },
        { dependency: 'third-party-lib', hasIntegrityCheck: true, isSecure: true }
      ]

      for (const test of integrityTests) {
        if (test.file) {
          expect(test.hasChecksum).toBe(test.isVerified)
        }
        if (test.update) {
          expect(test.isVerified).toBe(test.isSecure)
        }
        if (test.dependency) {
          expect(test.hasIntegrityCheck).toBe(test.isSecure)
        }
      }
    })

    it('should prevent security logging and monitoring failures (A09:2021)', () => {
      const loggingTests = [
        { event: 'login_failure', isLogged: true, isAudited: true, isSecure: true },
        { event: 'admin_action', isLogged: true, isAudited: true, isSecure: true },
        { event: 'password_change', isLogged: false, isAudited: false, isSecure: false },
        { event: 'suspicious_activity', isLogged: true, hasAlert: true, isSecure: true }
      ]

      for (const test of loggingTests) {
        const sensitiveEvents = ['login_failure', 'admin_action', 'password_change', 'suspicious_activity']
        const isSensitiveEvent = sensitiveEvents.includes(test.event)
        
        if (isSensitiveEvent) {
          expect(test.isLogged).toBe(test.isSecure)
        }
      }
    })

    it('should prevent server-side request forgery (A10:2021)', () => {
      const ssrfTests = [
        { url: 'http://localhost:8080/admin', isBlocked: true, isSecure: true },
        { url: 'http://169.254.169.254/latest/meta-data/', isBlocked: true, isSecure: true },
        { url: 'http://127.0.0.1:3000/internal', isBlocked: true, isSecure: true },
        { url: 'https://api.mexc.com/api/v3/ticker', isBlocked: false, isSecure: true }
      ]

      for (const test of ssrfTests) {
        const isInternalURL = test.url.includes('localhost') || 
                             test.url.includes('127.0.0.1') || 
                             test.url.includes('169.254.169.254') ||
                             test.url.includes('192.168.') ||
                             test.url.includes('10.')

        expect(isInternalURL).toBe(test.isBlocked)
      }
    })
  })

  describe('Common Weakness Enumeration (CWE) Validation', () => {
    it('should prevent buffer overflow vulnerabilities (CWE-120)', () => {
      const bufferTests = [
        { input: 'A'.repeat(1000), maxLength: 100, isVulnerable: true },
        { input: 'normal_input', maxLength: 100, isVulnerable: false },
        { input: 'B'.repeat(10000), maxLength: 1000, isVulnerable: true }
      ]

      for (const test of bufferTests) {
        const exceedsBuffer = test.input.length > test.maxLength
        expect(exceedsBuffer).toBe(test.isVulnerable)
      }
    })

    it('should prevent improper neutralization of special elements (CWE-79)', () => {
      const xssPayloads = SecurityTestDataGenerator.generateXSSPayloads()
      
      for (const payload of xssPayloads) {
        const hasXSS = /<script|<img|<svg|<iframe|javascript:|onload=|onerror=/i.test(payload)
        expect(hasXSS).toBe(true) // Should detect XSS patterns
      }
    })

    it('should prevent race condition vulnerabilities (CWE-362)', async () => {
      const raceConditionTests = [
        { operation: 'balance_update', concurrent: true, hasLock: false, isVulnerable: true },
        { operation: 'order_placement', concurrent: true, hasLock: true, isVulnerable: false },
        { operation: 'user_registration', concurrent: true, hasUniqueCheck: true, isVulnerable: false }
      ]

      for (const test of raceConditionTests) {
        if (test.operation === 'balance_update' && test.concurrent && !test.hasLock) {
          expect(test.isVulnerable).toBe(true)
        } else {
          expect(test.isVulnerable).toBe(false)
        }
      }
    })

    it('should prevent integer overflow vulnerabilities (CWE-190)', () => {
      const integerTests = [
        { value: Number.MAX_SAFE_INTEGER + 1, isOverflow: true },
        { value: -Number.MAX_SAFE_INTEGER - 1, isOverflow: true },
        { value: 1000000000, isOverflow: false },
        { value: 2147483648, isOverflow: true }, // 32-bit integer overflow
        { value: -2147483649, isOverflow: true }
      ]

      for (const test of integerTests) {
        const hasOverflow = test.value > Number.MAX_SAFE_INTEGER || 
                           test.value < Number.MIN_SAFE_INTEGER ||
                           test.value > 2147483647 ||
                           test.value < -2147483648

        expect(hasOverflow).toBe(test.isOverflow)
      }
    })

    it('should prevent use of hard-coded credentials (CWE-798)', () => {
      const credentialTests = [
        { code: 'const password = "admin123"', hasHardcodedCreds: true },
        { code: 'const apiKey = "mx0hardcodedkey"', hasHardcodedCreds: true },
        { code: 'const password = process.env.PASSWORD', hasHardcodedCreds: false },
        { code: 'const secret = await getFromVault()', hasHardcodedCreds: false }
      ]

      for (const test of credentialTests) {
        const hasHardcoded = /password\s*=\s*["'][^"']+["']|apiKey\s*=\s*["'][^"']+["']/i.test(test.code)
        expect(hasHardcoded).toBe(test.hasHardcodedCreds)
      }
    })

    it('should prevent missing encryption of sensitive data (CWE-311)', () => {
      const encryptionTests = [
        { dataType: 'password', encrypted: false, isVulnerable: true },
        { dataType: 'credit_card', encrypted: false, isVulnerable: true },
        { dataType: 'api_key', encrypted: true, isVulnerable: false },
        { dataType: 'public_info', encrypted: false, isVulnerable: false }
      ]

      const sensitiveDataTypes = ['password', 'credit_card', 'api_key', 'ssn', 'token']

      for (const test of encryptionTests) {
        const isSensitive = sensitiveDataTypes.includes(test.dataType)
        const shouldBeEncrypted = isSensitive && !test.encrypted
        
        expect(shouldBeEncrypted).toBe(test.isVulnerable)
      }
    })

    it('should prevent uncontrolled resource consumption (CWE-400)', async () => {
      mockCheckRateLimit.mockResolvedValue({
        success: false,
        resetTime: Date.now() + 60000,
        remainingAttempts: 0,
        reason: 'Rate limit exceeded'
      })

      const result = await checkRateLimit('127.0.0.1', '/api/test', 'general', 'TestAgent')
      
      expect(result.success).toBe(false)
      expect(result.reason).toContain('Rate limit')
    })
  })

  describe('Security Misconfiguration Detection', () => {
    it('should detect insecure default configurations', () => {
      const defaultConfigs = [
        { setting: 'admin_username', value: 'admin', isInsecure: true },
        { setting: 'admin_password', value: 'password', isInsecure: true },
        { setting: 'debug_mode', value: 'true', environment: 'production', isInsecure: true },
        { setting: 'cors_origin', value: '*', isInsecure: true },
        { setting: 'session_secret', value: 'default-secret', isInsecure: true }
      ]

      for (const config of defaultConfigs) {
        let isInsecure = false

        if (config.setting === 'admin_username' && config.value === 'admin') {
          isInsecure = true
        }
        if (config.setting === 'admin_password' && ['password', 'admin', '123456'].includes(config.value)) {
          isInsecure = true
        }
        if (config.setting === 'debug_mode' && config.value === 'true' && config.environment === 'production') {
          isInsecure = true
        }
        if (config.setting === 'cors_origin' && config.value === '*') {
          isInsecure = true
        }
        if (config.setting === 'session_secret' && config.value === 'default-secret') {
          isInsecure = true
        }

        expect(isInsecure).toBe(config.isInsecure)
      }
    })

    it('should detect exposed sensitive endpoints', () => {
      const endpointTests = [
        { path: '/.env', exposed: true, isInsecure: true },
        { path: '/config.json', exposed: true, isInsecure: true },
        { path: '/server-status', exposed: true, isInsecure: true },
        { path: '/phpinfo.php', exposed: true, isInsecure: true },
        { path: '/api/health', exposed: true, isInsecure: false }
      ]

      for (const test of endpointTests) {
        const sensitiveEndpoints = ['.env', 'config.json', 'server-status', 'phpinfo.php', 'admin.php']
        const isSensitive = sensitiveEndpoints.some(endpoint => test.path.includes(endpoint))
        
        const isInsecure = test.exposed && isSensitive
        expect(isInsecure).toBe(test.isInsecure)
      }
    })

    it('should detect insecure HTTP headers', () => {
      const headerTests = [
        { header: 'X-Frame-Options', value: null, isInsecure: true },
        { header: 'Content-Security-Policy', value: null, isInsecure: true },
        { header: 'Strict-Transport-Security', value: null, isInsecure: true },
        { header: 'X-Content-Type-Options', value: 'nosniff', isInsecure: false },
        { header: 'Server', value: 'Apache/2.4.41 (Ubuntu)', isInsecure: true }
      ]

      for (const test of headerTests) {
        const securityHeaders = ['X-Frame-Options', 'Content-Security-Policy', 'Strict-Transport-Security']
        const isSecurityHeader = securityHeaders.includes(test.header)
        
        let isInsecure = false
        if (isSecurityHeader && !test.value) {
          isInsecure = true
        }
        if (test.header === 'Server' && test.value && test.value.includes('Apache')) {
          isInsecure = true // Server version exposure
        }

        expect(isInsecure).toBe(test.isInsecure)
      }
    })

    it('should detect insecure SSL/TLS configuration', () => {
      const tlsTests = [
        { protocol: 'TLS 1.0', isInsecure: true },
        { protocol: 'TLS 1.1', isInsecure: true },
        { protocol: 'TLS 1.2', isInsecure: false },
        { protocol: 'TLS 1.3', isInsecure: false },
        { cipher: 'DES-CBC3-SHA', isInsecure: true },
        { cipher: 'AES256-GCM-SHA384', isInsecure: false }
      ]

      for (const test of tlsTests) {
        if (test.protocol) {
          const isOldProtocol = test.protocol === 'TLS 1.0' || test.protocol === 'TLS 1.1' || test.protocol.includes('SSL')
          expect(isOldProtocol).toBe(test.isInsecure)
        }
        
        if (test.cipher) {
          const isWeakCipher = test.cipher.includes('DES') || test.cipher.includes('RC4') || test.cipher.includes('MD5')
          expect(isWeakCipher).toBe(test.isInsecure)
        }
      }
    })
  })

  describe('Business Logic Vulnerability Testing', () => {
    it('should prevent price manipulation in trading', () => {
      const priceTests = [
        { originalPrice: '50000', manipulatedPrice: '0.01', isManipulation: true },
        { originalPrice: '50000', manipulatedPrice: '999999999', isManipulation: true },
        { originalPrice: '50000', manipulatedPrice: '49950', isManipulation: false },
        { originalPrice: '50000', manipulatedPrice: '-10000', isManipulation: true }
      ]

      for (const test of priceTests) {
        const original = parseFloat(test.originalPrice)
        const manipulated = parseFloat(test.manipulatedPrice)
        
        const priceChange = Math.abs((manipulated - original) / original) * 100
        const isNegative = manipulated <= 0
        const isExcessiveChange = priceChange > 10 // 10% threshold
        
        const isManipulation = isNegative || isExcessiveChange
        expect(isManipulation).toBe(test.isManipulation)
      }
    })

    it('should prevent quantity manipulation in orders', () => {
      const quantityTests = [
        { originalQty: '1.0', manipulatedQty: '1000000', isManipulation: true },
        { originalQty: '1.0', manipulatedQty: '-5.0', isManipulation: true },
        { originalQty: '1.0', manipulatedQty: '1.1', isManipulation: false },
        { originalQty: '1.0', manipulatedQty: '0', isManipulation: true }
      ]

      for (const test of quantityTests) {
        const original = parseFloat(test.originalQty)
        const manipulated = parseFloat(test.manipulatedQty)
        
        const isNegativeOrZero = manipulated <= 0
        const isExcessive = manipulated > original * 1000 // 1000x increase threshold
        
        const isManipulation = isNegativeOrZero || isExcessive
        expect(isManipulation).toBe(test.isManipulation)
      }
    })

    it('should prevent workflow bypass attempts', () => {
      const workflowTests = [
        { step: 'payment', status: 'pending', nextStep: 'fulfillment', isValidTransition: false },
        { step: 'payment', status: 'completed', nextStep: 'fulfillment', isValidTransition: true },
        { step: 'verification', status: 'pending', nextStep: 'trading', isValidTransition: false },
        { step: 'verification', status: 'approved', nextStep: 'trading', isValidTransition: true }
      ]

      for (const test of workflowTests) {
        const validTransitions = {
          'payment': { 'completed': ['fulfillment'], 'pending': [] },
          'verification': { 'approved': ['trading'], 'pending': [] }
        }

        const allowedNextSteps = validTransitions[test.step]?.[test.status] || []
        const isValidTransition = allowedNextSteps.includes(test.nextStep)
        
        expect(isValidTransition).toBe(test.isValidTransition)
      }
    })

    it('should prevent time-based manipulation', () => {
      const timeTests = [
        { requestTime: Date.now(), serverTime: Date.now() + 1000, threshold: 5000, isValid: true },
        { requestTime: Date.now(), serverTime: Date.now() + 10000, threshold: 5000, isValid: false },
        { requestTime: Date.now() - 86400000, serverTime: Date.now(), threshold: 3600000, isValid: false } // 24h old request
      ]

      for (const test of timeTests) {
        const timeDiff = Math.abs(test.serverTime - test.requestTime)
        const isWithinThreshold = timeDiff <= test.threshold
        
        expect(isWithinThreshold).toBe(test.isValid)
      }
    })
  })

  describe('Session Management Vulnerability Testing', () => {
    it('should prevent session fixation attacks', () => {
      const sessionTests = [
        { sessionId: 'fixed_session_123', beforeLogin: true, afterLogin: true, isVulnerable: true },
        { sessionId: 'session_abc', beforeLogin: true, afterLogin: false, isVulnerable: false },
        { sessionId: 'new_session_xyz', beforeLogin: false, afterLogin: true, isVulnerable: false }
      ]

      for (const test of sessionTests) {
        const sessionNotRegenerated = test.beforeLogin && test.afterLogin
        expect(sessionNotRegenerated).toBe(test.isVulnerable)
      }
    })

    it('should prevent session hijacking', () => {
      const hijackingTests = [
        { sessionId: 'predictable123', isPredictable: true, isVulnerable: true },
        { sessionId: SecurityTestHelpers.generateSecureRandom(32), isPredictable: false, isVulnerable: false },
        { userAgent: 'Mozilla/5.0 (Windows)', originalUA: 'Mozilla/5.0 (Linux)', isVulnerable: true },
        { ipAddress: '192.168.1.100', originalIP: '192.168.1.101', isVulnerable: true }
      ]

      for (const test of hijackingTests) {
        if (test.sessionId) {
          const isSecureSession = test.sessionId.length >= 32 && !test.isPredictable
          expect(!isSecureSession).toBe(test.isVulnerable)
        }
        
        if (test.userAgent && test.originalUA) {
          const agentChanged = test.userAgent !== test.originalUA
          expect(agentChanged).toBe(test.isVulnerable)
        }
        
        if (test.ipAddress && test.originalIP) {
          const ipChanged = test.ipAddress !== test.originalIP
          expect(ipChanged).toBe(test.isVulnerable)
        }
      }
    })

    it('should enforce session timeout', () => {
      const timeoutTests = [
        { lastActivity: Date.now() - 1800000, timeout: 1800000, shouldExpire: true }, // 30 min
        { lastActivity: Date.now() - 900000, timeout: 1800000, shouldExpire: false }, // 15 min
        { lastActivity: Date.now() - 7200000, timeout: 3600000, shouldExpire: true }, // 2 hours vs 1 hour timeout
        { lastActivity: Date.now() - 300000, timeout: 3600000, shouldExpire: false } // 5 min
      ]

      for (const test of timeoutTests) {
        const sessionAge = Date.now() - test.lastActivity
        const shouldExpire = sessionAge >= test.timeout
        
        expect(shouldExpire).toBe(test.shouldExpire)
      }
    })
  })
})